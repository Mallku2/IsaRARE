section \<open>Introduction\<close>

text\<open>
IsaRARE is a plugin for Isabelle that transforms rewrite rules in the RARE language into Isabelle
lemmas. It serves two main purposes:

\begin{enumerate}
\item Verification:
 Proving a lemma generated by IsaRARE indicates that the corresponding rule is sound.

\item Reconstruction:
 If rule is used in a proof certificate by an external solver, the generated lemmas can be used by
 the smt method during the reconstruction of that proof inside of Isabelle. 
\end{enumerate}

\<close>

section \<open>Set-up and Quick Usage\<close>

text\<open>
IsaRARE itself does not require any prerequisites but to execute the bit-vector examples in the
Tests/ folder a copy of Finite Machine Word Library from the Archive of Formal Proofs (AFP) is
needed \cite{WordLibAFP}. We have tested our tool with the version of the AFP from October 16, 2023.

IsaRARE can be used simply by importing IsaRARE.thy:
\<close>

theory IsaRARE
  imports "HOL-CVC.Smtlib_String" "HOL-CVC.SMT_CVC"
  keywords "parse_rare_file" "parse_rare" :: diag
begin

text\<open>
The two keywords the theory provides are used as follows:\\

1. To parse a single RARE rule use:

@{command "parse_rare"} <input rare rule as string> 

Example usage:

@{command "parse_rare"} "(define-rule bool-eq-true ((t Bool)) (= t true) t)"\\

2. To parse a RARE file:

@{command "parse_rare_file"} <input rare file, theory imports, new theory name>

Example usage

@{command "parse_rare_file"} "/IsaRARE/Tests/example\_rewrites" "Parent\_Theory" "Example\_Rewrites"

More information can be found in Section \ref{sec:use}.
\<close>



section \<open>The RARE language\<close>

text\<open>

The RARE language was introduced by N\"otzli et al.~\cite{notzli2022reconstructing}. A detailed
overview can be found on the cvc5 website
\footnote{\url{https://github.com/cvc5/cvc5/blob/main/src/rewriter/README.md}}.

A RARE file contains a list of rules whose syntax is defined by the grammar in Figure
\ref{fig:grammar}. Expressions use SMT-LIB syntax with a few exceptions. These include the use of
gradual types for parameterized sorts (e.g., arrays and bit-vectors) and the addition of a few
extra operators (e.g.,bvsize, described below). RARE uses SMT-LIB 3 syntax
\footnote{\url{http://smtlib.cs.uiowa.edu/version3.shtml}}, which while close to SMT-LIB 2,
mostly differs from its predecessor by the use of higher-order functions for indexed operators.

\begin{figure}[t]
    \grammarindent0.8in
    \renewcommand{\ulitleft}{\footnotesize \ttfamily \bfseries}
    \renewcommand{\ulitright}{}
    \footnotesize
    \begin{grammar}{\tiny}
      <rule> ::= "(" "define-rule" <symbol> "(" <par>$^*$ ")" [<defs>] <expr> <expr> ")"
      \alt "(" "define-rule*" <symbol> "(" <par>$^*$ ")" [<defs>] <expr> <expr> [<expr>] ")"
      \alt "(" "define-cond-rule" <symbol> "(" <par>$^*$ ")" [<defs>] <expr> <expr> <expr> ")"

      <par> ::= <symbol> <sort> [":list"]

      <sort> ::= <symbol> | "?" | "?"<symbol> | "(" <symbol> <numeral>$^+$ ")"

      <expr> ::= <const> | <id> | "(" <id> <expr>$^+$")"

      <id> ::= <symbol> | "(" <symbol> <numeral>$^+$ ")"

      <binding> ::= "(" <symbol> <expr> ")"

      <defs> ::= "(" "def" <binding>$^+$ ")"
    \end{grammar}

    \caption{Overview of the grammar of RARE.}
    \label{fig:grammar}
\end{figure}



The basic form of a RARE rewrite rule is defined using \rareInline{define-rule}. 
It starts with a parameter list containing variables with their sorts.  
These variables are used for matching as explained below.  
After an optional \emph{definition list} (see below), 
there are two expressions that form the main body of the rule:
the \emph{match} expression and the \emph{target} expression.
We say that an expression $e$ \emph{matches}
a match expression $m$ if there is some \emph{matching substitution} $\sigma$
that replaces each variable in $m$ by a term of the same sort to obtain $e$ 
(i.e., $m\sigma$ is syntactically identical to $e$).
For example, the expression \rareInline{(or (bvugt x1 x2) (= x2 x3))},
with variables \rareInline{x1}, \rareInline{x2}, \rareInline{x3}
all of sort \rareInline{?BitVec},
matches \rareInline{(or (bvugt a b) (= b a))}, 
but not \rareInline{(or (bvugt a b) (= c a))},
where \rareInline{a}, \rareInline{b}, and \rareInline{c} are constant symbols.
The semantics of a rule with match expression $m$ and target expression $t$
is that any expression $e$ matching $m$ under some matching substitution $\sigma$
can be replaced by $t\sigma$.


\<close>


section \<open>Components\<close>


text \<open>
All components of IsaRARE can be found in src/. In the following, we briefly summarize the function
of each component on a high level. Additional information can be found as source code comments in
the respective file.
\<close>

ML_file \<open>src/isarare_config.ML\<close>

text \<open>
This file provides diagnostics and options for IsaRARE. The options and their usage are described
in /ref{sec:options}
\<close>

ML_file \<open>src/parse_rare.ML\<close>

text \<open>
This file provides functionality to parse a RARE rule into a AST. This datatype is called
rewrite_tree and is defined in this file.
\<close>

ML_file \<open>src/rare_impl_assump.ML\<close>

text \<open>
This file provides enables the addition of assumptions to the AST whenever Isabelle's
definition of an operator is too general for SMT-LIB.
\<close>

ML_file \<open>src/rare_lists.ML\<close>

text \<open>
This file deals with the non SMT-LIB feature of RARE to use lists in rules (see Section TODO).
\<close>

ML_file \<open>src/write_rewrite_as_lemma.ML\<close>


text \<open>
In write_rewrite_as_lemma.ML the ASTs are translated into Isabelle terms and printed as lemmas. The
suggested proof is also generated here.
\<close>




ML \<open>
 open Parse_RARE
 open Write_Rewrite_as_Lemma

 (*TODO: Can I use: Library.cat_lines?*)
 fun string_of_rewrite ctxt s
  = (Write_Rewrite_as_Lemma.write_thy (Parse_RARE.parse_rewrites ctxt [s]) "THEORY_NAME" "IMPORTING_THEORIES" ctxt)

 fun print_rewrite (cs:string) (t:Toplevel.transition) :  Toplevel.transition =
  Toplevel.keep (fn toplevel => (fn state =>
   Print_Mode.with_modes [] (fn () => writeln (string_of_rewrite state cs)) ()) (Toplevel.context_of toplevel)) t

 val _ =
  Outer_Syntax.command \<^command_keyword>\<open>parse_rare\<close> "parse a single rule in rare format (provided as a string) and output lemma"
    ( Parse.string >> print_rewrite);

val ISARARE_HOME = OS.FileSys.getDir()

 val semi = Scan.option \<^keyword>\<open>;\<close>; (*TODO: Do not need?*)
val x = OS.Process.getEnv

 val _ =  Outer_Syntax.local_theory \<^command_keyword>\<open>parse_rare_file\<close> "parse file in rare format and output lemmas. <rare_file, import theories, target_theory>"
    (((Parse.string -- Parse.string)  -- Parse.string)
    >> (fn ((file_name,theory_imports),theory_name) => fn lthy =>
  let
          (*Built new path*)
          val file_path = Path.explode file_name
          val new_theory_name = theory_name ^ ".thy"
          val ctxt = Local_Theory.target_of lthy
          val res_path = Path.append (Path.dir file_path) (Path.basic new_theory_name)

          (*Calculate result*)
          (*val lines = raw_explode ( hd  (Bytes.contents (Bytes.read file_path))) ;*)
          val lines = Bytes.split_lines (Bytes.read file_path)
          val res =  (Write_Rewrite_as_Lemma.write_thy (Parse_RARE.parse_rewrites ctxt lines) theory_name theory_imports ctxt)
          val _ = (Output.writeln res)

          val _ =
           Bytes.write
            res_path (Bytes.string res)
          val _ = @{print} ("done writing to file", res_path)
 in  lthy
 end))
\<close>

lemmas cvc_arith_rewrite_defs = SMT.z3div_def


section \<open>Options\label{sec:options}\<close>

subsection \<open>General\<close>

text\<open>
@{attribute "IsaRARE_HOME"}<file\_path> can be used to change IsaRARE's home directory (which is the
location this file resides in by default). This is used to provide a relative path to the Tests
directory within Isabelle.
\<close>

subsection \<open>Traces and Debugging\<close>

text\<open>
To control the amount of information IsaRARE prints set @{attribute "IsaRARE_verbose"} to
<true|false>
\<close>

declare[[IsaRARE_verbose = true]] (*Get additional information*)

text\<open>
For debugging information set @{attribute "IsaRARE_verbose"} to <true|false>
\<close>

declare[[IsaRARE_debug = true]] (*Get debugging information*)

subsection \<open>Proofs\<close>

declare[[IsaRARE_implAssump = true]] (*Turn implicit assumption generation on or off (Warning this is an expert option: Lemmas might not be provable without the assumptions) *)
declare[[IsaRARE_listsAsVar = false]] (*When turned on list parameters are parsed as if they were variables (Warning this is an expert option: Lemmas might be proven but corresponding RARE rule is not correct) *)
declare[[IsaRARE_proofStrategy = "Minimum"]] (*Turn on specific strategies for proof printed, e.g. strings*)
declare[[ML_print_depth=10000]]

section \<open>Usage\label{sec:use}\<close>



section \<open>Test\<close>

parse_rare_file "Tests/mixed_rewrites" "" "Mixed_Rewrites"

subsection \<open>Regression Tests\<close>

text \<open>
IsaRARE contains a number of regression tests with RARE rules from various theories that are used
by the SMT solver cvc5. They can be found in Tests/Regression/.

\begin{center}
\begin{tabular}{ c | c | c }
 theory & rare file name & Isabelle theory name \\
 \hline
 EUF & euf\_rewrites & EUF\_Rewrites.thy \\
 Arithmetic & arith\_rewrites & Arith\_Rewrites.thy \\
 Sets & set\_rewrites & Set\_Rewrites.thy \\
 Arrays & array\_rewrites & Array\_Rewrites.thy \\
 Strings & string\_rewrites & String\_Rewrites.thy \\
 Bit-vectors & bv\_rewrites & Bitvector\_Rewrites.thy \\
             & bv\_rewrites\_proven & Bitvector\_Rewrites\_Proven.thy
\end{tabular}
\end{center}

For all theories except bit-vectors we were able to prove all lemmas corresponding to their rewrite
rules. For bit-vectors we therefore include two files; One with all the rewrite rules cvc5 uses
(bv\_rewrites) and one with the subset of these that we can prove (bv\_rewrites\_proven). The
corresponding Isabelle/HOL theories that contain the lemmas that IsaRARE generated are in the same
directory.

To run IsaRARE on all RARE files in Tests/ on the command line:

  isabelle build -d <path\_to\_afp>/thys/ -d. IsaRARE-Tests

To build the resulting theories (check that the proofs we provide work) run:

  isabelle build -d <path\_to\_afp>/thys/ -d. IsaRARE-Results

This checks all files except the bit-vector rewrites that we have not proven yet.

To use the graphical user interface open Tests/IsaRARE\_Tests.thy. 
\<close>



section \<open>Expansions (Experts) \<close>

(*TODO: Documentation adding new operators to parser*)

(*TODO: Documentation new_nary operators*)


section \<open>Limitations\<close>



(*
Note: IsaRARE can currently not deal with line breaks in rewrite rules
*)

end
