;approximate types and lists together. No complex approximate types

;arith
(define-rule arith-plus-zero ((t ? :list) (s ? :list)) (+ t 0 s) (+ t s))
(define-rule arith-mul-one ((t ? :list) (s ? :list)) (* t 1 s) (* t s))
(define-rule arith-mul-zero ((t ? :list) (s ? :list)) (* t 0 s) 0)
(define-rule* arith-plus-flatten ((xs ? :list) (w ?) (ys ? :list) (zs ? :list))
  (+ xs (+ w ys) zs)
  (+ xs w ys zs))
(define-rule* arith-mult-flatten ((xs ? :list) (w ?) (ys ? :list) (zs ? :list))
  (* xs (* w ys) zs)
  (* xs w ys zs))
(define-rule* arith-mult-dist ((x ?) (y ?) (z ?) (w ? :list))
  (* x (+ y z w))
  (+ (* x y) (* x (+ z w))))
(define-rule* arith-plus-cancel1 ((t ? :list) (x ?) (s ? :list) (r ? :list)) (+ t x s (* (- 1) x) r) (+ t s r))
(define-rule* arith-plus-cancel2 ((t ? :list) (x ?) (s ? :list) (r ? :list)) (+ t (* (- 1) x) s x r) (+ t s r))



;strings
(define-cond-rule str-eq-ctn-false ((x1 ? :list) (x ?) (x2 ? :list) (y ?))
  (= (str.contains y x) false)
  (= (str.++ x1 x x2) y)
  false)
(define-rule str-concat-flatten ((xs ? :list) (s ?) (ys ? :list) (zs ? :list))
  (str.++ xs (str.++ s ys) zs)
  (str.++ xs s ys zs))
(define-rule str-concat-flatten-eq ((x ?) (x1 ? :list) (x2 ? :list) (y ?))
  (= (str.++ (str.++ x x1) x2) y)
  (= y (str.++ x x1 x2)))
(define-rule str-concat-flatten-eq-rev ((x ?) (x1 ? :list) (x2 ? :list) (y ?))
  (= (str.++ x2 (str.++ x1 x)) y)
  (= y (str.++ x2 x1 x)))
(define-cond-rule str-substr-concat1 ((s1 ?) (s2 ? :list) (n Int) (m Int))
  (and (>= n 0) (>= (str.len s1) (+ n m)))
  (str.substr (str.++ s1 s2) n m)
  (str.substr s1 n m))
(define-rule str-contains-concat-find ((xs ? :list) (y ?) (zs ? :list)) 
  (str.contains (str.++ xs y zs) y) 
  true)
(define-cond-rule str-contains-split-char ((x ?) (y ?) (z ? :list) (w ?))
  (= (str.len w) 1)
  (str.contains (str.++ x y z) w)
  (or (str.contains x w) (str.contains (str.++ y z) w)))
